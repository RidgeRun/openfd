#!/usr/bin/env python
# ==========================================================================
#
# Copyright (C) 2012-2013 RidgeRun, LLC (http://www.ridgerun.com)
# All Rights Reserved.
#
# Authors: Jose Pablo Carballo <jose.carballo@ridgerun.com>
#          Diego Benavides <diego.benavides@ridgerun.com>
#
# The contents of this software are proprietary and confidential to RidgeRun,
# LLC.  No part of this program may be photocopied, reproduced or translated
# into another programming language without prior written consent of 
# RidgeRun, LLC.
#
# The installer tool objective is to provide several ways to deploy the
# firmware to the target board. 
#
# ==========================================================================

"""
Main entry point for the installer.

Please refer to the **User's Guide** for detailed information on how to call
this installer.
"""

# ==========================================================================
# Imports
# ==========================================================================

import time
import os
import sys
import argparse
import serial
import socket
import signal
import logging

import openfd.boards
import openfd.utils as utils
from openfd.utils.args import ArgCheckerError
from openfd.methods.board import BoardArgs
from openfd.methods.board import Uboot
from openfd.methods.board import UbootTimeoutException
from openfd.methods.board import TftpRamLoader
from openfd.methods.board import RamLoaderException
from openfd.methods.board import NandInstaller
from openfd.methods.board import NandExternalInstaller
from openfd.methods.board import EnvInstaller
from openfd.methods.sdcard import SdCardArgs
from openfd.methods.sdcard import ComponentInstaller
from openfd.methods.sdcard import SDCardInstaller

# ==========================================================================
# Global variables
# ==========================================================================

_args = []
_board_args = None
_sd_args = None
_parser = None
_subparsers = None
_logger  = None
_uboot = None
_board_factory = None

# ==========================================================================
# Constants
# ==========================================================================

# Modes
MODE_SD = 'sd'
MODE_SD_IMG = 'sd-img'
MODE_SD_SCRIPT = 'sd-script'
MODE_NAND = 'nand'
MODE_RAM = 'ram'
MODE_ENV = 'env'

# Components
COMP_IPL = "ipl"
COMP_BOOTLOADER = "bootloader"
COMP_KERNEL = "kernel"
COMP_FS = "fs"

# ==========================================================================
# Functions
# ==========================================================================

def _init_logging():
    global _logger
    _program_name = os.path.basename(sys.argv[0])
    _logger = utils.logger.init_global_logger(_program_name)
    _logger.setLevel(logging.DEBUG)
    streamhandler = logging.StreamHandler()
    streamhandler.setFormatter(logging.Formatter('%(msg)s'))
    if _args.verbose:
        streamhandler.setLevel(logging.DEBUG)
    else:
        streamhandler.setLevel(logging.INFO)
    if _args.quiet:
        streamhandler.setLevel(logging.CRITICAL)
    _logger.addHandler(streamhandler)
    if _args.log_filename:
        filehandler = logging.FileHandler(_args.log_filename, mode='a')
        filehandler.setLevel(logging.DEBUG)
        if _args.verbose:
            filehandler.setFormatter(logging.Formatter('%(levelname)s:'
                                           '%(filename)s:%(lineno)s: %(msg)s'))
        else:
            filehandler.setFormatter(logging.Formatter('%(msg)s'))
        _logger.addHandler(filehandler)
        _logger.debug('-' * 80)
        _logger.debug('Log date: %s' % time.strftime("%Y%m%d %H:%M:%S"))
        command = ''
        for arg in sys.argv:
            if ' ' in arg:
                command += ' "%s"' % arg
            else:
                command += ' %s' % arg
        _logger.debug('Command: %s' % command)

def _init_executer():
    utils.executer.init_global_executer(dryrun=_args.dryrun,
                                    enable_colors=True, verbose=_args.verbose)

def _init_boards():
    global _board_factory
    _board_factory = openfd.boards.board_factory.BoardFactory()

def _clean_exit(code=0):
    _close_uboot()
    if code != 0: _logger.debug('Exiting with code %d' % code)
    exit(code)

def _abort_install():
    _logger.error('Installation aborted')
    _clean_exit(-1)

def _sigint_handler(signal, frame):
    _logger.error('\nInstallation interrupted')
    _clean_exit(0)

def _check_is_dir(dirname, arg):
    if not os.path.isdir(dirname):
        _logger.error('Unable to find %s: %s' % (arg, dirname))
        _abort_install()

def _check_is_file(filename, arg):
    if not os.path.isfile(filename):
        _logger.error('Unable to find %s: %s' % (arg, filename))
        _abort_install()

def _check_x_ok(filename, arg):
    if not os.access(filename, os.X_OK):
        _logger.error('No execution permissions on %s: %s' % (arg, filename))
        _abort_install()

def _check_is_int(val, arg):
    try:
        int(val)
    except ValueError:
        _logger.error('%s must be an integer (%s)' % (arg, val))
        _abort_install()

def _check_is_valid_addr(addr, arg):
    if not utils.hexutils.is_valid_addr(addr):
        _logger.error('Invalid address on %s: %s' % (arg, addr))
        _abort_install()

def _check_is_valid_ipv4(ip, arg):
    try:
        socket.inet_aton(ip)
    except socket.error:
        _logger.error('Invalid IP address on %s: %s' % (arg, ip))
        _abort_install()

def _setup_uboot():
    global _uboot
    _uboot = Uboot()
    _uboot.serial_logger = _logger
    _uboot.dryrun = _args.dryrun
    try:
        ret = _uboot.open_comm(port=_args.serial_port, baud=_args.serial_baud)
        if ret is False: _abort_install()
        ret = _uboot.sync()
        if ret is False: _abort_install()
    except (serial.SerialException, UbootTimeoutException) as e:
            _logger.error(e)
            _abort_install()

def _close_uboot():
    if _uboot: _uboot.close_comm()

# ==========================================================================
# Command line arguments
# ==========================================================================
    
def _add_args():
    global _args
    global _board_args
    global _sd_args
    global _parser
    global _subparsers
    _parser = argparse.ArgumentParser()
    _board_args = BoardArgs()
    _sd_args = SdCardArgs()
    _subparsers = _parser.add_subparsers(help="installation mode (--help available)",
                                         dest="mode")
    
    _parser.add_argument('-y', '--assume-yes',
                       help='Automatic \'yes\' to prompts; '
                       'runs non-interactively',
                       dest='interactive',
                       action='store_false',
                       default=True)
    
    _parser.add_argument('-v', '--verbose',
                       help='Enable debug',
                       dest='verbose',
                       action='store_true',
                       default=False)
    
    _parser.add_argument('-q', '--quiet',
                       help='Be as quiet as possible',
                       dest='quiet',
                       action='store_true',
                       default=False)
    
    _parser.add_argument('-l', '--log',
                       help="Log to file",
                       metavar='<file>',
                       dest='log_filename')
    
    _parser.add_argument('--dryrun',
                       help='Sets the dryrun mode On (system and uboot '
                            'commands will be logged, but not executed)',
                       dest='dryrun',
                       action='store_true',
                       default=False)
    
    _add_args_nand()
    _add_args_sd()
    _add_args_sd_img()
    _add_args_sd_script()
    _add_args_ram()
    _add_args_env()

def _add_args_sd_shared(subparser):
    
    subparser.add_argument('--mmap-file',
                       help='Memory map config file',
                       metavar='<file>',
                       dest='mmap_file',
                       required=True)

    subparser.add_argument('--kernel-file',
                       help='Path to the Kernel file to be installed.',
                       metavar='<file>',
                       dest='kernel_file',
                       required=True)
    
    subparser.add_argument('--uflash-bin',
                       help='Path to the uflash tool',
                       metavar='<file>',
                       dest='uflash_bin',
                       required=True)
    
    subparser.add_argument('--ubl-file',
                       help='Path to the UBL file',
                       metavar='<file>',
                       dest='ubl_file',
                       required=True)
    
    subparser.add_argument('--uboot-file',
                       help='Path to the U-Boot file',
                       metavar='<file>',
                       dest='uboot_file',
                       required=True)
    
    subparser.add_argument('--uboot-entry-addr',
                       help='U-Boot entry address (decimal or hex)',
                       metavar='<addr>',
                       dest='uboot_entry_addr',
                       required=True)
    
    subparser.add_argument('--uboot-load-addr',
                       help='U-Boot load address (decimal or hex)',
                       metavar='<addr>',
                       dest='uboot_load_addr',
                       required=True)
    
    subparser.add_argument('--uboot-bootargs',
                       help='U-Boot bootargs environment variable (passed to" \
                       " the Linux kernel)',
                       metavar='<bootargs>',
                       dest='uboot_bootargs',
                       required=True)
    
    subparser.add_argument('--work-dir',
                       help='Directory to perform temporary operations',
                       metavar='<dir>',
                       dest='workdir',
                       required=True)
    
    subparser.add_argument('--rootfs',
                       help='Path to the rootfs that will be installed.',
                       metavar='<dir>',
                       dest='rootfs',
                       default=None)
    
def _add_args_sd():
    parser_sd = _subparsers.add_parser(MODE_SD)
    _sd_args.add_args_sd(parser_sd)

def _add_args_sd_img():
    parser_sd_img = _subparsers.add_parser(MODE_SD_IMG)
    _sd_args.add_args_sd_img(parser_sd_img)

def _add_args_sd_script():
    parser_sd_script = _subparsers.add_parser(MODE_SD_SCRIPT)
    _sd_args.add_args_sd_script(parser_sd_script)

def _add_args_nand():
    parser_nand = _subparsers.add_parser(MODE_NAND)
    subparsers_nand = parser_nand.add_subparsers(help="component "
                                       "(--help available)", dest="component")
    parser_nand_ipl = subparsers_nand.add_parser(COMP_IPL,
                                       help="Initial Program Loader (UBL)")
    parser_nand_bootloader = subparsers_nand.add_parser(COMP_BOOTLOADER,
                                                  help="Bootloader (U-Boot)")
    parser_nand_kernel = subparsers_nand.add_parser(COMP_KERNEL, help="Kernel")
    parser_nand_fs = subparsers_nand.add_parser(COMP_FS, help="Filesystem")
    _board_args.add_args_nand(parser_nand)
    _board_args.add_args_nand_ipl(parser_nand_ipl)
    _board_args.add_args_nand_bootloader(parser_nand_bootloader)
    _board_args.add_args_nand_kernel(parser_nand_kernel)
    _board_args.add_args_nand_fs(parser_nand_fs)

def _add_args_ram():
    parser_ram = _subparsers.add_parser(MODE_RAM)
    _board_args.add_args_ram(parser_ram)
    
def _add_args_env():
    parser_env = _subparsers.add_parser(MODE_ENV)
    _board_args.add_args_env(parser_env)
    
def _check_args():
    try:
        if _args.mode == MODE_SD:
            _sd_args.check_args_sd(_args)
        elif _args.mode == MODE_SD_IMG:
            _sd_args.check_args_sd_img(_args)
        elif _args.mode == MODE_SD_SCRIPT:
            _sd_args.check_args_sd_script(_args)
        elif _args.mode == MODE_NAND:
            _board_args.check_args_nand(_args)
        elif _args.mode == MODE_RAM:
            _board_args.check_args_ram(_args)
        elif _args.mode == MODE_ENV:
            _board_args.check_args_env(_args)        
    except ArgCheckerError as e:
        _logger.error(e)
        _abort_install()

def _check_sudo():
    ret = utils.get_global_executer().prompt_sudo()
    if ret != 0:
        _logger.error("Failed obtaining superuser access via sudo")
        _clean_exit(-1)

# ==========================================================================
# Main logic
# ==========================================================================

def main():
    global _uboot
    global _args
    signal.signal(signal.SIGINT, _sigint_handler)
    signal.signal(signal.SIGTERM, _sigint_handler)
    _init_boards()
    _add_args()
    _args = _parser.parse_args()
    _init_logging()
    _init_executer()
    _check_args()
    
    mode = _args.mode
    
    mode_requires_sudo = [MODE_SD, MODE_SD_IMG]
    if mode in mode_requires_sudo:
        _check_sudo() 
    
    if mode == MODE_SD or mode == MODE_SD_IMG:
        
        # Components installer
        
        comp_installer = ComponentInstaller()
        comp_installer.uflash_bin = _args.uflash_bin
        comp_installer.ubl_file =_args.ubl_file
        comp_installer.uboot_file = _args.uboot_file
        comp_installer.uboot_entry_addr = _args.uboot_entry_addr
        comp_installer.uboot_load_addr = _args.uboot_load_addr
        comp_installer.bootargs = _args.uboot_bootargs
        comp_installer.kernel_image = _args.kernel_file
        comp_installer.rootfs = _args.rootfs
        comp_installer.workdir = _args.workdir
        
        # SDCard installer
    
        sd_installer = SDCardInstaller(comp_installer)
        sd_installer.interactive = _args.interactive
        sd_installer.dryrun = _args.dryrun
        
        ret = sd_installer.read_partitions(_args.mmap_file)
        if ret is False: _abort_install()
        
        # Operations
        
        if mode == MODE_SD:
            sd_installer.device = _args.device
            sd_installer.mode = sd_installer.MODE_SD
            ret = sd_installer.format_sd()
            if ret is False: _abort_install()
        elif mode == MODE_SD_IMG:
            sd_installer.mode = sd_installer.MODE_LOOPBACK
            ret = sd_installer.format_loopdevice(_args.image, 
                                                 _args.imagesize_mb)
            if ret is False: _abort_install()
        
        ret = sd_installer.mount_partitions(_args.workdir)
        if ret is False: _abort_install()
        
        ret = sd_installer.install_components()
        if ret is False: _abort_install()
        
        ret = sd_installer.release_device()
        if ret is False: _abort_install()
        
    if mode == MODE_NAND or mode == MODE_RAM:
        _setup_uboot()
        try:
            tftp_loader = TftpRamLoader(_uboot, _args.board_net_mode)
            tftp_loader.dir = _args.tftp_dir
            tftp_loader.port = _args.tftp_port
            tftp_loader.host_ipaddr = _args.host_ip_addr
            tftp_loader.net_mode = _args.board_net_mode
            if _args.board_net_mode == TftpRamLoader.MODE_STATIC:
                tftp_loader.board_ipaddr = _args.board_ip_addr
            tftp_loader.dryrun = _args.dryrun
            
            if mode == MODE_NAND:
                
                comp_requires_network = [COMP_IPL, COMP_BOOTLOADER, COMP_KERNEL,
                                     COMP_FS]
            
                if _args.component in comp_requires_network:
                    tftp_loader.setup_uboot_network()
            
                nand_installer = NandInstaller(uboot=_uboot, loader=tftp_loader)
                if _args.nand_blk_size:
                    nand_installer.nand_block_size = _args.nand_blk_size
                if _args.nand_page_size:
                    nand_installer.nand_page_size = _args.nand_page_size
                nand_installer.ram_load_addr = _args.ram_load_addr
                nand_installer.dryrun = _args.dryrun
                nand_installer.read_partitions(_args.mmap_file)
                
                if _args.nand_uboot_file:
                    ret = nand_installer.load_uboot_to_ram(_args.nand_uboot_file,
                                                           _args.ram_load_addr)
                    if ret is False: _abort_install()
                
                if _args.component == COMP_IPL:
                    ret = nand_installer.install_ipl(force=_args.ipl_force)
                    if ret is False: _abort_install()
                    
                if _args.component == COMP_BOOTLOADER:
                    ret = nand_installer.install_bootloader()
                    if ret is False: _abort_install()
                    
                if _args.component == COMP_KERNEL:
                    ret = nand_installer.install_kernel(force=_args.kernel_force)
                    if ret is False: _abort_install()
        
                if _args.component == COMP_FS:
                    ret = nand_installer.install_fs(force=_args.fs_force)
                    if ret is False: _abort_install()
            
                _logger.debug("Finishing installation")
                if _args.component in comp_requires_network:
                    if _uboot.get_env('autostart') == 'no':
                        _uboot.set_env('autostart', 'yes')
                        _uboot.save_env()
                        
                _uboot.cmd('echo Installation complete', prompt_timeout=None)
                        
            if mode == MODE_RAM:
                tftp_loader.setup_uboot_network()
                _logger.info("Loading %s to RAM address %s" %
                             (_args.ram_file, _args.ram_load_addr))
                tftp_loader.load_file_to_ram_and_boot(_args.ram_file,
                                  _args.ram_load_addr, _args.ram_boot_line,
                                  boot_timeout=_args.ram_boot_timeout)
            
        except (UbootTimeoutException, RamLoaderException) as e:
            _logger.error(e)
            _abort_install()
        _close_uboot()
        
    if mode == MODE_ENV:
        _setup_uboot()
        try:
            env_installer = EnvInstaller(uboot=_uboot)
            env_installer.dryrun = _args.dryrun
            env_installer.install_variable(_args.env_variable,
                                        _args.env_value, _args.env_force)
        except UbootTimeoutException as e:
            _logger.error(e)
            _abort_install()
        _close_uboot()
        
    if mode == MODE_SD_SCRIPT:
        board = _board_factory.make(_args.board)
        ext_installer = NandExternalInstaller(board=board)
        ext_installer.read_partitions(_args.mmap_file)
        ext_installer.install_boardinfo()
        ext_installer.install_ipl()
        ext_installer.install_bootloader()
        ext_installer.install_kernel()
        ext_installer.install_fs()
        ext_installer.write(_args.template_file, _args.output_file)
        
    _logger.info('Installation complete')
    _clean_exit(0)
    
if __name__ == '__main__':
    main()
